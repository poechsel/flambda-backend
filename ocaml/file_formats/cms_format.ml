(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                   Fabrice Le Fessant, INRIA Saclay                     *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Cmi_format
open Typedtree

(* Note that in Typerex, there is an awful hack to save a cms file
   together with the interface file that was generated by ocaml (this
   is because the installed version of ocaml might differ from the one
   integrated in Typerex).
*)



let read_magic_number ic =
  let len_magic_number = String.length Config.cms_magic_number in
  really_input_string ic len_magic_number

type item_declaration =
  | Class_declaration of class_declaration
  | Class_description of class_description
  | Class_type_declaration of class_type_declaration
  | Extension_constructor of extension_constructor
  | Module_binding of module_binding
  | Module_declaration of module_declaration
  | Module_type_declaration of module_type_declaration
  | Type_declaration of type_declaration
  | Value_binding of value_binding
  | Value_description of value_description

type cms_infos = {
  cms_modname : Compilation_unit.t;
  cms_comments : (string * Location.t) list;
  cms_args : string array;
  cms_sourcefile : string option;
  cms_builddir : string;
  cms_loadpath : string list;
  cms_source_digest : Digest.t option;
  cms_interface_digest : Digest.t option;
  cms_uid_to_attributes : attributes Shape.Uid.Tbl.t;
  cms_impl_shape : Shape.t option; (* None for mli *)
}

type error =
    Not_a_shape of string

let uid_to_attributes : attributes Types.Uid.Tbl.t ref =
  Local_store.s_table Types.Uid.Tbl.create 16

let register_uid uid fragment =
  Types.Uid.Tbl.add !uid_to_attributes uid fragment

let iter_decl =
  Tast_iterator.{ default_iterator with

  value_bindings = (fun sub ((_, vbs) as bindings) ->
    let bound_idents = let_bound_idents_full_with_bindings vbs in
    List.iter
      (fun (vb, (_id, _loc, _typ, uid)) ->
        register_uid uid vb.vb_attributes)
      bound_idents;
      default_iterator.value_bindings sub bindings);

  module_binding = (fun sub mb ->
    register_uid mb.mb_decl_uid mb.mb_attributes;
    default_iterator.module_binding sub mb);

  module_declaration = (fun sub md ->
    register_uid md.md_uid md.md_attributes;
    default_iterator.module_declaration sub md);

  module_type_declaration = (fun sub mtd ->
    register_uid mtd.mtd_uid mtd.mtd_attributes;
    default_iterator.module_type_declaration sub mtd);

  value_description = (fun sub vd ->
    register_uid vd.val_val.val_uid vd.val_attributes;
    default_iterator.value_description sub vd);

  type_declaration = (fun sub td ->
    (* compiler-generated "row_names" share the uid of their corresponding
        class declaration, so we ignore them to prevent duplication *)
    if not (Btype.is_row_name (Ident.name td.typ_id)) then
      register_uid td.typ_type.type_uid td.typ_attributes;
      default_iterator.type_declaration sub td);

  extension_constructor = (fun sub ec ->
    register_uid ec.ext_type.ext_uid ec.ext_attributes;
    default_iterator.extension_constructor sub ec);

  class_declaration = (fun sub cd ->
    register_uid cd.ci_decl.cty_uid cd.ci_attributes;
    default_iterator.class_declaration sub cd);

  class_type_declaration = (fun sub ctd ->
    register_uid ctd.ci_decl.cty_uid ctd.ci_attributes;
    default_iterator.class_type_declaration sub ctd);

  class_description =(fun sub cd ->
    register_uid cd.ci_decl.cty_uid cd.ci_attributes;
    default_iterator.class_description sub cd); }

let gather_declarations_in_part = function
  | Cmt_format.Partial_structure s -> iter_decl.structure iter_decl s
  | Cmt_format.Partial_structure_item s -> iter_decl.structure_item iter_decl s
  | Cmt_format.Partial_expression e -> iter_decl.expr iter_decl e
  | Cmt_format.Partial_pattern (_category, p) -> iter_decl.pat iter_decl p
  | Cmt_format.Partial_class_expr ce -> iter_decl.class_expr iter_decl ce
  | Cmt_format.Partial_signature s -> iter_decl.signature iter_decl s
  | Cmt_format.Partial_signature_item s -> iter_decl.signature_item iter_decl s
  | Cmt_format.Partial_module_type s -> iter_decl.module_type iter_decl s

let gather_declarations binary_annots =
  match binary_annots with
  | Cmt_format.Implementation s -> iter_decl.structure iter_decl s
  | Cmt_format.Interface s -> iter_decl.signature iter_decl s
  | Cmt_format.Packed _ -> ()
  | Cmt_format.Partial_implementation array -> Array.iter gather_declarations_in_part array
  | Cmt_format.Partial_interface array -> Array.iter gather_declarations_in_part array

exception Error of error

let input_cms ic = (input_value ic : cms_infos)

let output_cms oc cms =
  output_string oc Config.cms_magic_number;
  output_value oc (cms : cms_infos)

let read filename =
(*  Printf.fprintf stderr "cms_format.read %s\n%!" filename; *)
  let ic = open_in_bin filename in
  Misc.try_finally
    ~always:(fun () -> close_in ic)
    (fun () ->
       let magic_number = read_magic_number ic in
       let cmi, cms =
         if magic_number = Config.cms_magic_number then
           None, Some (input_cms ic)
         else if magic_number = Config.cmi_magic_number then
           let cmi = Cmi_format.input_cmi ic in
           let cms = try
               let magic_number = read_magic_number ic in
               if magic_number = Config.cms_magic_number then
                 let cms = input_cms ic in
                 Some cms
               else None
             with _ -> None
           in
           Some cmi, cms
         else
           raise(Cmi_format.Error(Cmi_format.Not_an_interface filename))
       in
       cmi, cms
    )

let read_cms filename =
  match read filename with
      _, None -> raise (Error (Not_a_shape filename))
    | _, Some cms -> cms

let read_cmi filename =
  match read filename with
      None, _ ->
        raise (Cmi_format.Error (Cmi_format.Not_an_interface filename))
    | Some cmi, _ -> cmi

let save_cms filename modname binary_annots sourcefile cmi shape =
  if !Clflags.binary_annotations && not !Clflags.print_types then begin
    Misc.output_to_file_via_temporary
       ~mode:[Open_binary] filename
       (fun temp_file_name oc ->
         let this_crc =
           match cmi with
           | None -> None
           | Some cmi -> Some (output_cmi temp_file_name oc cmi)
         in
         let source_digest = Option.map Digest.file sourcefile in
         gather_declarations binary_annots;
         let cms = {
           cms_modname = modname;
           cms_comments = Lexer.comments ();
           cms_args = Sys.argv;
           cms_sourcefile = sourcefile;
           cms_builddir = Location.rewrite_absolute_path (Sys.getcwd ());
           cms_loadpath = Load_path.get_paths ();
           cms_source_digest = source_digest;
           cms_interface_digest = this_crc;
           cms_uid_to_attributes = !uid_to_attributes;
           cms_impl_shape = shape;
         } in
         output_cms oc cms)
  end
